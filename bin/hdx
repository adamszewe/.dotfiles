#!/usr/bin/env python3

# @author   : Adam Szewera
# @version  : 2016-06-28

import git
import os
import sys
import re
import getopt
import shutil

REGEX_PACKAGE_NAME_PATTERN = re.compile('([a-zA-Z_$][a-zA-Z\d_$]*\.)*[a-zA-Z_$][a-zA-Z\d_$]*')
DEFAULT_PACKAGE_NAME = 'it.synesthesia.skeletonapp'
TMP_DIR_NAME = "__temp__"
GITLAB_DEFAULT_REPOSITORY = "git@gitlab.com:synesthesia_android_projects/syn_skeleton_app.git"



global_vars = {
    'new_package_name': 'it.synesthesia.skeletonapp'
}



################################################################################
##
##                             REFACTOR
##
################################################################################
def rename_dirs(path, old_package_name, new_package_name):
    new_package_dirs = new_package_name.split('.')
    old_package_dirs = old_package_name.split('.')

    if len(new_package_dirs) != len(old_package_dirs):
        print("the package names have different number of dirs in them")
    if len(new_package_dirs) != len(old_package_dirs):
        old_tree = os.sep.join(old_package_dirs)
        new_tree = os.sep.join(new_package_dirs)
        shutil.copytree(old_tree, new_tree)
        shutil.rmtree(old_tree)
        shutil.rmtree(old_package_dirs[0])          # remove the old path starting from its root
        return

    for i in range(0, len(old_package_dirs)):
        os.rename(old_package_dirs[i], new_package_dirs[i])
        os.chdir(new_package_dirs[i])

    # go back to the parent dir
    for i in range(0, len(new_package_dirs)):
        os.chdir('..')



def root_package(package_name, levels):
    """Returns the package name with as many levels as specified - the remaining part is truncated"""
    return '.'.join(package_name.split('.')[0:levels])



def refactor_java_file(file_name, old_package, new_package):
    if new_package.startswith('.'):
        new_package = new_package[1:]
    tmp_file_name = '__tmp_' + file_name
    with open(file_name, 'r') as file_src, open(tmp_file_name, 'w') as tmp_file:
        content = file_src.readlines()
        for line in content:
            if line.startswith("package"):
                tmp_file.write("package %s;\n" % new_package)
            elif line.startswith("import"):
                # replace_string = root_package( new_package, len( old_package.split('.') ) )
                line = line.replace(old_package, global_vars['new_package_name'])
                tmp_file.write(line)
            else:
                tmp_file.write(line)
    file_src.close()
    tmp_file.close()
    os.remove(file_name)
    os.rename(tmp_file_name, file_name)



def refactor_directory_tree(path, old_package_name, new_package_name, level):
    os.chdir(path)
    dirs = []
    java_files = []
    for f in os.listdir(os.curdir):
        if os.path.isdir(f):
            dirs.append(f)
        elif f.endswith(".java"):
            java_files.append(f)

    for d in dirs:
        if level == 0:
            refactor_directory_tree(d, old_package_name, '', level + 1)
        else:
            refactor_directory_tree(d, old_package_name, new_package_name + '.' + path, level + 1)
    for jf in java_files:
        refactor_java_file(jf, old_package_name, new_package_name + '.' + path)

    # back to parent
    os.chdir('..')

def refactor(project_path, old_package_name, new_package_name):
    if is_valid_package_name(new_package_name):
        os.chdir(project_path)
        if os.path.isdir('app') and os.path.isdir('app%ssrc' % os.sep):
            os.chdir('app%ssrc' % os.sep)
            dirs = [d for d in os.listdir(os.curdir) if os.path.isdir(d)]
            for d in dirs:

                os.chdir(d)

                # todo: extract the constant file name
                if (os.path.exists("AndroidManifest.xml")):
                    refactor_manifest("AndroidManifest.xml", new_package_name)


                if os.path.isdir('java'):
                    os.chdir('java')
                    if package_exists(old_package_name):
                        rename_dirs('.', old_package_name, new_package_name)
                        refactor_directory_tree('.', old_package_name, '', 0)
                    else:
                        print('package doesn\'t exist ---- ' + old_package_name)
                    os.chdir('..')
                    # os.chdir('..')

    print('ok')


################################################################################
##
##                         COMMANDS & UTILS
##
################################################################################
def is_valid_package_name(package_name):
    """Basic check for the Java package name"""
    return REGEX_PACKAGE_NAME_PATTERN.match(package_name)



def package_exists(package_name):
    parts = package_name.split('.')
    depth = 0
    exists = True
    for part in parts:
        if os.path.isdir(part):
            os.chdir(part)
            depth += 1
        else:
            exists = False
            break
    # back to parent
    while depth > 0:
        os.chdir('..')
        depth -= 1
    return exists



def usage():
    print("Usage:\n")
    for command in commands:
        short_version = "-" + "".join([c for c in command[0] if c is not ":"])
        long_version = "--" + "".join([c for c in command[1] if c is not "="])
        if len(command[1]) == 0:
            long_version = ""
        description = command[2]
        print("%s  %5s    %s" % (long_version.ljust(16), short_version, description))
    print("\n")



def new_project(project_name):
    # clone git repo and refactor the package names
    pass




def refactor_manifest(manifest_file_name, new_package_name):
    """Changes the value of the package attribute inside a AndroidManifest.xml file"""
    pattern = r"package=(\"|').*(\"|')"
    tmp_file_name = '__tmp_' + manifest_file_name
    with open(manifest_file_name, 'r') as manifest_file, open(tmp_file_name, 'w') as tmp_file:
        content = manifest_file.read()
        content = re.sub(pattern, 'package="%s"' % new_package_name, content)
        tmp_file.write(content)
    os.remove(manifest_file_name)
    os.rename(tmp_file_name, manifest_file_name)




def download_skeleton_repo():
    if os.path.isdir(TMP_DIR_NAME):
        shutil.rmtree(TMP_DIR_NAME)
    os.mkdir(TMP_DIR_NAME)

    repo = git.Repo.init(TMP_DIR_NAME)
    origin = repo.create_remote('origin', GITLAB_DEFAULT_REPOSITORY)
    origin.fetch()
    origin.pull(origin.refs[0].remote_head)





################################################################################
##
##                             EXECUTION
##
################################################################################
commands = [
    ('h', 'help', 'displays this help message'),
    ('d:', 'dir=', 'define the path to the project'),
    ('n:', 'new=', 'create a new project with the given name'),
    ('z:', 'old-package=', 'specify the old package name - default is ' + DEFAULT_PACKAGE_NAME),
    ('r:', 'refactor=', 'parameter: <package name> refactor with the given package name'),
]


def main(argv):
    if len(sys.argv) == 0:
        usage()

    # variables
    project_path = '.'
    old_package_name = DEFAULT_PACKAGE_NAME


    try:
        short_commands = ''.join(c[0] for c in commands)
        long_commands = [c[1] for c in commands]
        opts, args = getopt.getopt(argv, short_commands, long_commands)
    except getopt.GetoptError:
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()

        if opt in ('-d', '--dir'):
            project_path = arg

        if opt in ('-n', '--new'):
            print('cloning the project')
            project_name = arg
            download_skeleton_repo()
            os.rename(TMP_DIR_NAME, project_name)


        if opt in ('-z', '--zir'):
            old_package_name = arg

        if opt in ('-r', '--refactor-package'):
            new_package_name = arg
            global_vars['new_package_name'] = new_package_name
            refactor(project_path, old_package_name, new_package_name)





if __name__ == "__main__":
    # we need to be in the root folder of the project to execute this script
    main(sys.argv[1:])




